
Downgrade dxcore to Wine 10.8
Afterwards apply two patches from ElementalWarrior's wine branch


diff -uNarp a/configure b/configure
--- a/configure	2025-06-13 16:45:16.000000000 -0400
+++ b/configure	2025-11-21 09:30:24.682561765 -0500
@@ -22341,7 +22341,6 @@ wine_fn_config_makefile dlls/dwrite enab
 wine_fn_config_makefile dlls/dwrite/tests enable_tests
 wine_fn_config_makefile dlls/dx8vb enable_dx8vb
 wine_fn_config_makefile dlls/dxcore enable_dxcore
-wine_fn_config_makefile dlls/dxcore/tests enable_tests
 wine_fn_config_makefile dlls/dxdiagn enable_dxdiagn
 wine_fn_config_makefile dlls/dxdiagn/tests enable_tests
 wine_fn_config_makefile dlls/dxgi enable_dxgi
diff -uNarp a/configure.ac b/configure.ac
--- a/configure.ac	2025-06-13 16:45:16.000000000 -0400
+++ b/configure.ac	2025-11-21 09:30:37.098584227 -0500
@@ -2701,7 +2701,6 @@ WINE_CONFIG_MAKEFILE(dlls/dwrite)
 WINE_CONFIG_MAKEFILE(dlls/dwrite/tests)
 WINE_CONFIG_MAKEFILE(dlls/dx8vb)
 WINE_CONFIG_MAKEFILE(dlls/dxcore)
-WINE_CONFIG_MAKEFILE(dlls/dxcore/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxdiagn)
 WINE_CONFIG_MAKEFILE(dlls/dxdiagn/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxgi)
diff -uNarp a/dlls/dxcore/dxcore.c b/dlls/dxcore/dxcore.c
--- a/dlls/dxcore/dxcore.c	2025-06-13 16:45:16.000000000 -0400
+++ b/dlls/dxcore/dxcore.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,530 +0,0 @@
-/*
- * Copyright (C) 2023 Mohamad Al-Jaf
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <stdarg.h>
-
-#define COBJMACROS
-#include "initguid.h"
-#include "dxcore.h"
-#include "wine/wined3d.h"
-
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
-
-struct dxcore_adapter
-{
-    IDXCoreAdapter IDXCoreAdapter_iface;
-    LONG refcount;
-
-    struct wined3d_adapter_identifier identifier;
-};
-
-static inline struct dxcore_adapter *impl_from_IDXCoreAdapter(IDXCoreAdapter *iface)
-{
-    return CONTAINING_RECORD(iface, struct dxcore_adapter, IDXCoreAdapter_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryInterface(IDXCoreAdapter *iface, REFIID riid, void **out)
-{
-    struct dxcore_adapter *adapter = impl_from_IDXCoreAdapter(iface);
-
-    TRACE("iface %p, riid %s, out %p.\n", iface, debugstr_guid(riid), out);
-
-    if (IsEqualGUID(riid, &IID_IDXCoreAdapter)
-            || IsEqualGUID(riid, &IID_IUnknown))
-    {
-        *out = &adapter->IDXCoreAdapter_iface;
-        IUnknown_AddRef((IUnknown *)*out);
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(riid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_AddRef(IDXCoreAdapter *iface)
-{
-    struct dxcore_adapter *adapter = impl_from_IDXCoreAdapter(iface);
-    ULONG refcount = InterlockedIncrement(&adapter->refcount);
-
-    TRACE("%p increasing refcount to %lu.\n", iface, refcount);
-
-    return refcount;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_Release(IDXCoreAdapter *iface)
-{
-    struct dxcore_adapter *adapter = impl_from_IDXCoreAdapter(iface);
-    ULONG refcount = InterlockedDecrement(&adapter->refcount);
-
-    TRACE("%p decreasing refcount to %lu.\n", iface, refcount);
-
-    if (!refcount)
-        free(adapter);
-
-    return refcount;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_IsValid(IDXCoreAdapter *iface)
-{
-    FIXME("iface %p stub!\n", iface);
-    return FALSE;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_IsAttributeSupported(IDXCoreAdapter *iface, REFGUID attribute)
-{
-    FIXME("iface %p, attribute %s stub!\n", iface, debugstr_guid(attribute));
-    return FALSE;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_IsPropertySupported(IDXCoreAdapter *iface, DXCoreAdapterProperty property)
-{
-    FIXME("iface %p, property %u stub!\n", iface, property);
-    return FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_GetProperty(IDXCoreAdapter *iface, DXCoreAdapterProperty property,
-        size_t buffer_size, void *buffer)
-{
-    struct dxcore_adapter *adapter = impl_from_IDXCoreAdapter(iface);
-
-    TRACE("iface %p, property %u, buffer_size %Iu, buffer %p\n", iface, property, buffer_size, buffer);
-
-    if (!buffer)
-        return E_POINTER;
-
-    switch (property)
-    {
-        case HardwareID:
-        {
-            struct DXCoreHardwareID *hardware_id = buffer;
-
-            if (buffer_size != sizeof(DXCoreHardwareID))
-                return E_INVALIDARG;
-
-            hardware_id->vendorID = adapter->identifier.vendor_id;
-            hardware_id->deviceID = adapter->identifier.device_id;
-            hardware_id->subSysID = adapter->identifier.subsystem_id;
-            hardware_id->revision = adapter->identifier.revision;
-            break;
-        }
-        default:
-        {
-            FIXME("property %u not implemented.\n", property);
-            return DXGI_ERROR_INVALID_CALL;
-        }
-    }
-
-    return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_GetPropertySize(IDXCoreAdapter *iface, DXCoreAdapterProperty property,
-        size_t *buffer_size)
-{
-    FIXME("iface %p, property %u, buffer_size %p stub!\n", iface, property, buffer_size);
-    return E_NOTIMPL;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_IsQueryStateSupported(IDXCoreAdapter *iface, DXCoreAdapterState property)
-{
-    FIXME("iface %p, property %u stub!\n", iface, property);
-    return FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryState(IDXCoreAdapter *iface, DXCoreAdapterState state, size_t state_details_size,
-        const void *state_details, size_t buffer_size, void *buffer)
-{
-    FIXME("iface %p, state %u, state_details_size %Iu, state_details %p, buffer_size %Iu, buffer %p stub!\n",
-            iface, state, state_details_size, state_details, buffer_size, buffer);
-    return E_NOTIMPL;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_IsSetStateSupported(IDXCoreAdapter *iface, DXCoreAdapterState property)
-{
-    FIXME("iface %p, property %u stub!\n", iface, property);
-    return FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_SetState(IDXCoreAdapter *iface, DXCoreAdapterState state, size_t state_details_size,
-        const void *state_details, size_t buffer_size, const void *buffer)
-{
-    FIXME("iface %p, state %u, state_details_size %Iu, state_details %p, buffer_size %Iu, buffer %p stub!\n",
-            iface, state, state_details_size, state_details, buffer_size, buffer);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_GetFactory(IDXCoreAdapter *iface, REFIID riid, void **out)
-{
-    FIXME("iface %p, riid %s, out %p stub!\n", iface, debugstr_guid(riid), out);
-    return E_NOTIMPL;
-}
-
-static const struct IDXCoreAdapterVtbl dxcore_adapter_vtbl =
-{
-    /* IUnknown methods */
-    dxcore_adapter_QueryInterface,
-    dxcore_adapter_AddRef,
-    dxcore_adapter_Release,
-    /* IDXCoreAdapter methods */
-    dxcore_adapter_IsValid,
-    dxcore_adapter_IsAttributeSupported,
-    dxcore_adapter_IsPropertySupported,
-    dxcore_adapter_GetProperty,
-    dxcore_adapter_GetPropertySize,
-    dxcore_adapter_IsQueryStateSupported,
-    dxcore_adapter_QueryState,
-    dxcore_adapter_IsSetStateSupported,
-    dxcore_adapter_SetState,
-    dxcore_adapter_GetFactory,
-};
-
-struct dxcore_adapter_list
-{
-    IDXCoreAdapterList IDXCoreAdapterList_iface;
-    LONG refcount;
-
-    struct dxcore_adapter **adapters;
-    uint32_t adapter_count;
-};
-
-static inline struct dxcore_adapter_list *impl_from_IDXCoreAdapterList(IDXCoreAdapterList *iface)
-{
-    return CONTAINING_RECORD(iface, struct dxcore_adapter_list, IDXCoreAdapterList_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_QueryInterface(IDXCoreAdapterList *iface, REFIID riid, void **out)
-{
-    struct dxcore_adapter_list *list = impl_from_IDXCoreAdapterList(iface);
-
-    TRACE("iface %p, riid %s, out %p.\n", iface, debugstr_guid(riid), out);
-
-    if (IsEqualGUID(riid, &IID_IDXCoreAdapterList)
-            || IsEqualGUID(riid, &IID_IUnknown))
-    {
-        *out = &list->IDXCoreAdapterList_iface;
-        IUnknown_AddRef((IUnknown *)*out);
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(riid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_list_AddRef(IDXCoreAdapterList *iface)
-{
-    struct dxcore_adapter_list *list = impl_from_IDXCoreAdapterList(iface);
-    ULONG refcount = InterlockedIncrement(&list->refcount);
-
-    TRACE("%p increasing refcount to %lu.\n", iface, refcount);
-
-    return refcount;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_list_Release(IDXCoreAdapterList *iface)
-{
-    struct dxcore_adapter_list *list = impl_from_IDXCoreAdapterList(iface);
-    ULONG refcount = InterlockedDecrement(&list->refcount);
-
-    TRACE("%p decreasing refcount to %lu.\n", iface, refcount);
-
-    if (!refcount)
-    {
-        for (UINT i = 0; i < list->adapter_count; i++)
-        {
-            if (list->adapters[i])
-                IDXCoreAdapter_Release(&list->adapters[i]->IDXCoreAdapter_iface);
-        }
-        free(list->adapters);
-        free(list);
-    }
-    return refcount;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetAdapter(IDXCoreAdapterList *iface, uint32_t index,
-        REFIID riid, void **out)
-{
-    struct dxcore_adapter_list *list = impl_from_IDXCoreAdapterList(iface);
-    IDXCoreAdapter *adapter;
-
-    TRACE("iface %p, index %u, riid %s, out %p\n", iface, index, debugstr_guid(riid), out);
-
-    if (!out)
-        return E_POINTER;
-
-    if (index >= list->adapter_count)
-    {
-        *out = NULL;
-        return E_INVALIDARG;
-    }
-
-    adapter = &list->adapters[index]->IDXCoreAdapter_iface;
-    TRACE("returning IDXCoreAdapter %p for index %u.\n", adapter, index);
-    return IDXCoreAdapter_QueryInterface(adapter, riid, out);
-}
-
-static uint32_t STDMETHODCALLTYPE dxcore_adapter_list_GetAdapterCount(IDXCoreAdapterList *iface)
-{
-    struct dxcore_adapter_list *list = impl_from_IDXCoreAdapterList(iface);
-
-    TRACE("iface %p\n", iface);
-
-    return list->adapter_count;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsStale(IDXCoreAdapterList *iface)
-{
-    FIXME("iface %p stub!\n", iface);
-    return FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetFactory(IDXCoreAdapterList *iface, REFIID riid, void **out)
-{
-    FIXME("iface %p, riid %s, out %p stub!\n", iface, debugstr_guid(riid), out);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_Sort(IDXCoreAdapterList *iface, uint32_t num_preferences,
-        const DXCoreAdapterPreference *preferences)
-{
-    FIXME("iface %p, num_preferences %u, preferences %p stub!\n", iface, num_preferences, preferences);
-    return E_NOTIMPL;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsAdapterPreferenceSupported(IDXCoreAdapterList *iface,
-        DXCoreAdapterPreference preference)
-{
-    FIXME("iface %p, preference %u stub!\n", iface, preference);
-    return FALSE;
-}
-
-static const struct IDXCoreAdapterListVtbl dxcore_adapter_list_vtbl =
-{
-    /* IUnknown methods */
-    dxcore_adapter_list_QueryInterface,
-    dxcore_adapter_list_AddRef,
-    dxcore_adapter_list_Release,
-    /* IDXCoreAdapterList methods */
-    dxcore_adapter_list_GetAdapter,
-    dxcore_adapter_list_GetAdapterCount,
-    dxcore_adapter_list_IsStale,
-    dxcore_adapter_list_GetFactory,
-    dxcore_adapter_list_Sort,
-    dxcore_adapter_list_IsAdapterPreferenceSupported,
-};
-
-struct dxcore_adapter_factory
-{
-    IDXCoreAdapterFactory IDXCoreAdapterFactory_iface;
-    LONG refcount;
-};
-
-static inline struct dxcore_adapter_factory *impl_from_IDXCoreAdapterFactory(IDXCoreAdapterFactory *iface)
-{
-    return CONTAINING_RECORD(iface, struct dxcore_adapter_factory, IDXCoreAdapterFactory_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_factory_QueryInterface(IDXCoreAdapterFactory *iface, REFIID riid, void **out)
-{
-    struct dxcore_adapter_factory *factory = impl_from_IDXCoreAdapterFactory(iface);
-
-    TRACE("iface %p, riid %s, out %p.\n", iface, debugstr_guid(riid), out);
-
-    if (IsEqualGUID(riid, &IID_IDXCoreAdapterFactory)
-            || IsEqualGUID(riid, &IID_IUnknown))
-    {
-        *out = &factory->IDXCoreAdapterFactory_iface;
-        IUnknown_AddRef((IUnknown *)*out);
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(riid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_factory_AddRef(IDXCoreAdapterFactory *iface)
-{
-    struct dxcore_adapter_factory *factory = impl_from_IDXCoreAdapterFactory(iface);
-    ULONG refcount = InterlockedIncrement(&factory->refcount);
-
-    TRACE("%p increasing refcount to %lu.\n", iface, refcount);
-
-    return refcount;
-}
-
-static ULONG STDMETHODCALLTYPE dxcore_adapter_factory_Release(IDXCoreAdapterFactory *iface)
-{
-    struct dxcore_adapter_factory *factory = impl_from_IDXCoreAdapterFactory(iface);
-    ULONG refcount = InterlockedDecrement(&factory->refcount);
-
-    TRACE("%p decreasing refcount to %lu.\n", iface, refcount);
-
-    if (!refcount)
-        free(factory);
-
-    return refcount;
-}
-
-static HRESULT get_adapters(struct dxcore_adapter_list *list)
-{
-    struct wined3d *wined3d = wined3d_create(0);
-    HRESULT hr = S_OK;
-
-    if (!wined3d)
-        return E_FAIL;
-
-    if (!(list->adapter_count = wined3d_get_adapter_count(wined3d)))
-        goto done;
-
-    if (!(list->adapters = calloc(list->adapter_count, sizeof(*list->adapters))))
-    {
-        hr = E_OUTOFMEMORY;
-        goto done;
-    }
-
-    for (UINT i = 0; i < list->adapter_count; i++)
-    {
-        struct dxcore_adapter *dxcore_adapter = calloc(1, sizeof(*dxcore_adapter));
-        const struct wined3d_adapter *wined3d_adapter;
-
-        if (!dxcore_adapter)
-        {
-            hr = E_OUTOFMEMORY;
-            goto done;
-        }
-
-        wined3d_adapter = wined3d_get_adapter(wined3d, i);
-        if (FAILED(hr = wined3d_adapter_get_identifier(wined3d_adapter, 0, &dxcore_adapter->identifier)))
-        {
-            free(dxcore_adapter);
-            goto done;
-        }
-
-        dxcore_adapter->IDXCoreAdapter_iface.lpVtbl = &dxcore_adapter_vtbl;
-        dxcore_adapter->refcount = 1;
-
-        list->adapters[i] = dxcore_adapter;
-    }
-
-done:
-    wined3d_decref(wined3d);
-    return hr;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_factory_CreateAdapterList(IDXCoreAdapterFactory *iface, uint32_t num_attributes,
-        const GUID *filter_attributes, REFIID riid, void **out)
-{
-    struct dxcore_adapter_list *list;
-    HRESULT hr;
-
-    FIXME("iface %p, num_attributes %u, filter_attributes %p, riid %s, out %p semi-stub!\n", iface, num_attributes, filter_attributes,
-            debugstr_guid(riid), out);
-
-    if (!out)
-        return E_POINTER;
-
-    *out = NULL;
-
-    if (!num_attributes || !filter_attributes)
-        return E_INVALIDARG;
-
-    if (!(list = calloc(1, sizeof(*list))))
-        return E_OUTOFMEMORY;
-
-    list->IDXCoreAdapterList_iface.lpVtbl = &dxcore_adapter_list_vtbl;
-    list->refcount = 1;
-    if (FAILED(hr = get_adapters(list)))
-    {
-        IDXCoreAdapterList_Release(&list->IDXCoreAdapterList_iface);
-        return hr;
-    }
-
-    hr = IDXCoreAdapterList_QueryInterface(&list->IDXCoreAdapterList_iface, riid, out);
-    IDXCoreAdapterList_Release(&list->IDXCoreAdapterList_iface);
-    TRACE("created IDXCoreAdapterList %p.\n", *out);
-    return hr;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_factory_GetAdapterByLuid(IDXCoreAdapterFactory *iface, REFLUID adapter_luid,
-        REFIID riid, void **out)
-{
-    FIXME("iface %p, adapter_luid %p, riid %s, out %p stub!\n", iface, adapter_luid, debugstr_guid(riid), out);
-    return E_NOTIMPL;
-}
-
-static BOOL STDMETHODCALLTYPE dxcore_adapter_factory_IsNotificationTypeSupported(IDXCoreAdapterFactory *iface, DXCoreNotificationType type)
-{
-    FIXME("iface %p, type %u stub!\n", iface, type);
-    return FALSE;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_factory_RegisterEventNotification(IDXCoreAdapterFactory *iface, IUnknown *dxcore_object,
-        DXCoreNotificationType type, PFN_DXCORE_NOTIFICATION_CALLBACK callback, void *callback_context, uint32_t *event_cookie)
-{
-    FIXME("iface %p, dxcore_object %p, type %u, callback %p, callback_context %p, event_cookie %p stub!\n", iface, dxcore_object, type, callback,
-            callback_context, event_cookie);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE dxcore_adapter_factory_UnregisterEventNotification(IDXCoreAdapterFactory *iface, uint32_t event_cookie)
-{
-    FIXME("iface %p, event_cookie %u stub!\n", iface, event_cookie);
-    return E_NOTIMPL;
-}
-
-static const struct IDXCoreAdapterFactoryVtbl dxcore_adapter_factory_vtbl =
-{
-    /* IUnknown methods */
-    dxcore_adapter_factory_QueryInterface,
-    dxcore_adapter_factory_AddRef,
-    dxcore_adapter_factory_Release,
-    /* IDXCoreAdapterFactory methods */
-    dxcore_adapter_factory_CreateAdapterList,
-    dxcore_adapter_factory_GetAdapterByLuid,
-    dxcore_adapter_factory_IsNotificationTypeSupported,
-    dxcore_adapter_factory_RegisterEventNotification,
-    dxcore_adapter_factory_UnregisterEventNotification,
-};
-
-HRESULT STDMETHODCALLTYPE DXCoreCreateAdapterFactory(REFIID riid, void **out)
-{
-    static struct dxcore_adapter_factory *factory = NULL;
-
-    TRACE("riid %s, out %p\n", debugstr_guid(riid), out);
-
-    if (!out)
-        return E_POINTER;
-
-    if (!factory)
-    {
-        if (!(factory = calloc(1, sizeof(*factory))))
-        {
-            *out = NULL;
-            return E_OUTOFMEMORY;
-        }
-
-        factory->IDXCoreAdapterFactory_iface.lpVtbl = &dxcore_adapter_factory_vtbl;
-        factory->refcount = 0;
-    }
-
-    TRACE("created IDXCoreAdapterFactory %p.\n", *out);
-    return IDXCoreAdapterFactory_QueryInterface(&factory->IDXCoreAdapterFactory_iface, riid, out);
-}
diff -uNarp a/dlls/dxcore/main.c b/dlls/dxcore/main.c
--- a/dlls/dxcore/main.c	1969-12-31 19:00:00.000000000 -0500
+++ b/dlls/dxcore/main.c	2025-05-16 15:59:26.000000000 -0400
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "dxcore.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
+
+HRESULT WINAPI DXCoreCreateAdapterFactory( REFIID riid, void **ppv )
+{
+    FIXME( "riid %s, ppv %p stub!\n", debugstr_guid(riid), ppv );
+    return E_NOINTERFACE;
+}
diff -uNarp a/dlls/dxcore/Makefile.in b/dlls/dxcore/Makefile.in
--- a/dlls/dxcore/Makefile.in	2025-06-13 16:45:16.000000000 -0400
+++ b/dlls/dxcore/Makefile.in	2025-05-16 15:59:26.000000000 -0400
@@ -1,7 +1,6 @@
-MODULE  = dxcore.dll
-IMPORTS = wined3d
+MODULE = dxcore.dll
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
 SOURCES = \
-	dxcore.c
+	main.c
diff -uNarp a/dlls/dxcore/tests/dxcore.c b/dlls/dxcore/tests/dxcore.c
--- a/dlls/dxcore/tests/dxcore.c	2025-06-13 16:45:16.000000000 -0400
+++ b/dlls/dxcore/tests/dxcore.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,184 +0,0 @@
-/*
- * Copyright (C) 2025 Mohamad Al-Jaf
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <stdarg.h>
-
-#define COBJMACROS
-#include "initguid.h"
-#include "dxcore.h"
-
-#include "wine/test.h"
-
-static HRESULT (WINAPI *pDXCoreCreateAdapterFactory)(REFIID riid, void **out);
-
-#define check_interface(iface, riid, supported) check_interface_(__LINE__, iface, riid, supported)
-static void check_interface_(unsigned int line, void *iface, REFIID riid, BOOL supported)
-{
-    IUnknown *unknown = iface, *out;
-    HRESULT hr, expected_hr;
-
-    expected_hr = supported ? S_OK : E_NOINTERFACE;
-
-    hr = IUnknown_QueryInterface(unknown, riid, (void **)&out);
-    ok_(__FILE__, line)(hr == expected_hr, "got hr %#lx.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(out);
-}
-
-static void test_DXCoreCreateAdapterFactory(void)
-{
-    IDXCoreAdapterFactory *factory2 = (void *)0xdeadbeef;
-    IDXCoreAdapterFactory *factory = (void *)0xdeadbeef;
-    IDXCoreAdapterList *list2 = (void *)0xdeadbeef;
-    IDXCoreAdapterList *list = (void *)0xdeadbeef;
-    IDXCoreAdapter *adapter2 = (void *)0xdeadbeef;
-    IDXCoreAdapter *adapter = (void *)0xdeadbeef;
-    struct DXCoreHardwareID *hardware_id;
-    void *buffer = (void *)0xdeadbeef;
-    uint32_t adapter_count = 0;
-    LONG refcount;
-    HRESULT hr;
-
-    if (0) /* Crashes on w1064v1909 */
-    {
-        hr = pDXCoreCreateAdapterFactory(NULL, NULL);
-        ok(hr == E_POINTER, "got hr %#lx.\n", hr);
-    }
-    hr = pDXCoreCreateAdapterFactory(&IID_IDXCoreAdapterFactory, NULL);
-    ok(hr == E_POINTER || broken(hr == E_NOINTERFACE) /* w1064v1909 */, "got hr %#lx.\n", hr);
-    hr = pDXCoreCreateAdapterFactory(&DXCORE_ADAPTER_ATTRIBUTE_D3D11_GRAPHICS, (void **)&factory);
-    ok(hr == E_NOINTERFACE, "got hr %#lx.\n", hr);
-    ok(factory == NULL || broken(factory == (void *)0xdeadbeef) /* w1064v1909 */, "got factory %p.\n", factory);
-
-    hr = pDXCoreCreateAdapterFactory(&IID_IDXCoreAdapterFactory, (void **)&factory);
-    ok(hr == S_OK || broken(hr == E_NOINTERFACE) /* w1064v1909 */, "got hr %#lx.\n", hr);
-    if (FAILED(hr))
-        return;
-
-    hr = pDXCoreCreateAdapterFactory(&IID_IDXCoreAdapterFactory, (void **)&factory2);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    ok(factory == factory2, "got factory %p, factory2 %p.\n", factory, factory2);
-    refcount = IDXCoreAdapterFactory_Release(factory2);
-    ok(refcount == 1, "got refcount %ld.\n", refcount);
-
-    check_interface(factory, &IID_IAgileObject, FALSE);
-    check_interface(factory, &IID_IDXCoreAdapter, FALSE);
-    check_interface(factory, &IID_IDXCoreAdapterList, FALSE);
-
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 0, &DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, &IID_IDXCoreAdapterList, (void **)&list);
-    ok(hr == E_INVALIDARG, "got hr %#lx.\n", hr);
-    ok(list == NULL, "got list %p.\n", list);
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 1, &DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, &IID_IDXCoreAdapterFactory, (void **)&list);
-    ok(hr == E_NOINTERFACE, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 1, NULL, &IID_IDXCoreAdapterFactory, (void **)&list);
-    ok(hr == E_INVALIDARG, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 1, &DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, &IID_IDXCoreAdapterFactory, NULL);
-    ok(hr == E_POINTER, "got hr %#lx.\n", hr);
-
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 1, &DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, &IID_IDXCoreAdapterList, (void **)&list);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapterFactory_CreateAdapterList(factory, 1, &DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, &IID_IDXCoreAdapterList, (void **)&list2);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    ok(list != list2, "got same list %p, list2 %p.\n", list, list);
-    refcount = IDXCoreAdapterList_Release(list2);
-    ok(refcount == 0, "got refcount %ld.\n", refcount);
-
-    check_interface(list, &IID_IAgileObject, FALSE);
-    check_interface(list, &IID_IDXCoreAdapter, FALSE);
-    check_interface(list, &IID_IDXCoreAdapterFactory, FALSE);
-
-    adapter_count = IDXCoreAdapterList_GetAdapterCount(list);
-    ok(adapter_count != 0, "got adapter_count 0.\n");
-
-    hr = IDXCoreAdapterList_GetAdapter(list, 0xdeadbeef, &IID_IDXCoreAdapter, NULL);
-    ok(hr == E_POINTER, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapterList_GetAdapter(list, adapter_count, &IID_IDXCoreAdapter, (void **)&adapter);
-    ok(hr == E_INVALIDARG, "got hr %#lx.\n", hr);
-    ok(adapter == NULL, "got adapter %p.\n", adapter);
-    hr = IDXCoreAdapterList_GetAdapter(list, 0, &IID_IDXCoreAdapterList, (void **)&adapter);
-    ok(hr == E_NOINTERFACE, "got hr %#lx.\n", hr);
-
-    hr = IDXCoreAdapterList_GetAdapter(list, 0, &IID_IDXCoreAdapter, (void **)&adapter);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapterList_GetAdapter(list, 0, &IID_IDXCoreAdapter, (void **)&adapter2);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    ok(adapter == adapter2, "got adapter %p, adapter2 %p.\n", adapter, adapter2);
-    refcount = IDXCoreAdapter_Release(adapter2);
-    todo_wine
-    ok(refcount == 3, "got refcount %ld.\n", refcount);
-
-    check_interface(adapter, &IID_IAgileObject, FALSE);
-    check_interface(adapter, &IID_IDXCoreAdapterList, FALSE);
-    check_interface(adapter, &IID_IDXCoreAdapterFactory, FALSE);
-
-    hr = IDXCoreAdapter_GetProperty(adapter, HardwareID, 0, NULL);
-    ok(hr == E_POINTER, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapter_GetProperty(adapter, HardwareID, 0, buffer);
-    ok(hr == E_INVALIDARG, "got hr %#lx.\n", hr);
-    hr = IDXCoreAdapter_GetProperty(adapter, 0xdeadbeef, 0, buffer);
-    ok(hr == DXGI_ERROR_INVALID_CALL, "got hr %#lx.\n", hr);
-
-    buffer = calloc(1, sizeof(HardwareID));
-    ok(buffer != NULL, "failed to allocate memory for buffer.\n");
-    hr = IDXCoreAdapter_GetProperty(adapter, HardwareID, sizeof(HardwareID), buffer);
-    ok(hr == E_INVALIDARG, "got hr %#lx.\n", hr);
-    free(buffer);
-    buffer = calloc(1, sizeof(DXCoreHardwareID));
-    ok(buffer != NULL, "failed to allocate memory for buffer.\n");
-    hr = IDXCoreAdapter_GetProperty(adapter, 0xdeadbeef, sizeof(DXCoreHardwareID), buffer);
-    ok(hr == DXGI_ERROR_INVALID_CALL, "got hr %#lx.\n", hr);
-    free(buffer);
-
-    buffer = calloc(1, sizeof(DXCoreHardwareID));
-    ok(buffer != NULL, "failed to allocate memory for buffer.\n");
-    hr = IDXCoreAdapter_GetProperty(adapter, HardwareID, sizeof(DXCoreHardwareID), buffer);
-    ok(hr == S_OK, "got hr %#lx.\n", hr);
-    hardware_id = buffer;
-    ok(hardware_id->vendorID != 0, "failed to get vendorID\n");
-    ok(hardware_id->deviceID != 0, "failed to get deviceID\n");
-    free(buffer);
-
-    refcount = IDXCoreAdapter_Release(adapter);
-    todo_wine
-    ok(refcount == 2, "got refcount %ld.\n", refcount);
-    refcount = IDXCoreAdapterList_Release(list);
-    ok(refcount == 0, "got refcount %ld.\n", refcount);
-    refcount = IDXCoreAdapterFactory_Release(factory);
-    ok(refcount == 0, "got refcount %ld.\n", refcount);
-}
-
-START_TEST(dxcore)
-{
-    HMODULE dxcore_handle = LoadLibraryA("dxcore.dll");
-    if (!dxcore_handle)
-    {
-        win_skip("Could not load dxcore.dll\n");
-        return;
-    }
-    pDXCoreCreateAdapterFactory = (void *)GetProcAddress(dxcore_handle, "DXCoreCreateAdapterFactory");
-    if (!pDXCoreCreateAdapterFactory)
-    {
-        win_skip("Failed to get DXCoreCreateAdapterFactory address, skipping dxcore tests\n");
-        FreeLibrary(dxcore_handle);
-        return;
-    }
-
-    test_DXCoreCreateAdapterFactory();
-
-    FreeLibrary(dxcore_handle);
-}
diff -uNarp a/dlls/dxcore/tests/Makefile.in b/dlls/dxcore/tests/Makefile.in
--- a/dlls/dxcore/tests/Makefile.in	2025-06-13 16:45:16.000000000 -0400
+++ b/dlls/dxcore/tests/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,5 +0,0 @@
-TESTDLL = dxcore.dll
-IMPORTS = uuid
-
-SOURCES = \
-	dxcore.c
-- 
2.47.1


ElementalWarrior wine patch series
https://gitlab.winehq.org/ElementalWarrior/wine/-/commits/affinity-photo3-wine9.13-part3

__avg__ patch for dxcore (e4f264a1)
Trying to resolve segfault (5ff68569)


diff -uNarp a/dlls/dxcore/adapter.c b/dlls/dxcore/adapter.c
--- a/dlls/dxcore/adapter.c	1969-12-31 19:00:00.000000000 -0500
+++ b/dlls/dxcore/adapter.c	2025-11-18 23:34:50.665913031 -0500
@@ -0,0 +1,342 @@
+#include "private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
+
+
+// -- IDXCoreAdapter --
+static inline struct dxcore_adapter *impl_from_IDXCoreAdapter(IDXCoreAdapter *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_adapter, IDXCoreAdapter_iface);
+}
+
+
+HRESULT dxcore_adapter_pInstanceLuid(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    DXGI_ADAPTER_DESC desc;
+
+    if (lenBuffer < sizeof(LUID))
+        return E_INVALIDARG;
+
+    hr = IDXGIAdapter_GetDesc(this->adapter, &desc);
+    if (FAILED(hr))
+        return hr;
+
+    memcpy(buffer, (void*)&desc.AdapterLuid, sizeof(&desc.AdapterLuid));
+    return S_OK;
+}
+HRESULT dxcore_adapter_pDriverVersion(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    LARGE_INTEGER res;
+    if (lenBuffer < sizeof(uint64_t))
+        return E_INVALIDARG;
+
+    hr = IDXGIAdapter_CheckInterfaceSupport(this->adapter, &IID_IDXGIDevice, &res);
+    TRACE("Driver version; h %ld, l %ld, q %lld.\n", res.HighPart, res.LowPart, res.QuadPart);
+    memcpy(buffer, &res, sizeof(res));
+    return hr;
+}
+HRESULT dxcore_adapter_pDriverDescription(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    size_t len;
+    DXGI_ADAPTER_DESC desc;
+
+    hr = IDXGIAdapter_GetDesc(this->adapter, &desc);
+    if (FAILED(hr))
+        return hr;
+
+    len = wcslen(desc.Description);
+
+    if (lenBuffer < len+1)
+        return E_INVALIDARG;
+
+    wcstombs(buffer, desc.Description, sizeof(desc.Description));
+    TRACE("Driver Description: '%s'\n", (char *)buffer);
+    return S_OK;
+}
+HRESULT dxcore_adapter_pHardwareID(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    DXGI_ADAPTER_DESC desc;
+    DXCoreHardwareID result;
+
+    if (lenBuffer < sizeof(result))
+        return E_INVALIDARG;
+
+    if (FAILED(hr = IDXGIAdapter_GetDesc(this->adapter, &desc)))
+        return hr;
+
+    result.vendorID = desc.VendorId;
+    result.deviceID = desc.DeviceId;
+    result.subSysID = desc.SubSysId;
+    result.revision = desc.Revision;
+
+    memcpy(buffer, &result, sizeof(result));
+    return S_OK;
+}
+// ...
+HRESULT dxcore_adapter_pIsHardware(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    char result = TRUE;
+    if (lenBuffer < sizeof(result))
+        return E_INVALIDARG;
+
+    memcpy(buffer, &result, sizeof(result));
+    return S_OK;
+}
+
+
+HRESULT (*dxcore_adapter_properties[])(struct dxcore_adapter *, size_t, void*) = {
+    dxcore_adapter_pInstanceLuid,
+    dxcore_adapter_pDriverVersion,
+    dxcore_adapter_pDriverDescription,
+    dxcore_adapter_pHardwareID,
+    NULL, // dxcore_adapter_pKmdModelVersion,
+    NULL, // dxcore_adapter_pComputePreemptionGranularity,
+    NULL, // dxcore_adapter_pGraphicsPreemptionGranularity,
+    NULL, // dxcore_adapter_pDedicatedAdapterMemory,
+    NULL, // dxcore_adapter_pDedicatedSystemMemory,
+    NULL, // dxcore_adapter_pSharedSystemMemory,
+    NULL, // dxcore_adapter_pAcgCompatible,
+    dxcore_adapter_pIsHardware,
+    NULL, // dxcore_adapter_pIsIntegrated,
+    NULL, // dxcore_adapter_pIsDetachable,
+    NULL, // dxcore_adapter_pHardwareIDParts,
+    NULL, // dxcore_adapter_pPhysicalAdapterCount,
+    NULL, // dxcore_adapter_pAdapterEngineCount,
+    NULL // dxcore_adapter_pAdapterEngineName
+};
+
+size_t dxcore_adapter_sInstanceLuid(struct dxcore_adapter *adapter) {
+    return sizeof(LUID);
+}
+size_t dxcore_adapter_sDriverVersion(struct dxcore_adapter *adapter) {
+    return sizeof(uint64_t);
+}
+size_t dxcore_adapter_sDriverDescription(struct dxcore_adapter *adapter) {
+    DXGI_ADAPTER_DESC desc;
+    if (FAILED(IDXGIAdapter_GetDesc(adapter->adapter, &desc)))
+        return 0;
+    return wcslen(desc.Description)+1;
+}
+size_t dxcore_adapter_sHardwareID(struct dxcore_adapter *adapter) {
+    return sizeof(DXCoreHardwareID);
+}
+size_t dxcore_adapter_sIsHardware(struct dxcore_adapter *adapter) {
+    return 1;
+}
+
+size_t (*dxcore_adapter_property_sizes[])(struct dxcore_adapter *) = {
+    dxcore_adapter_sInstanceLuid,
+    dxcore_adapter_sDriverVersion,
+    dxcore_adapter_sDriverDescription,
+    dxcore_adapter_sHardwareID,
+    NULL, // dxcore_adapter_pKmdModelVersion,
+    NULL, // dxcore_adapter_pComputePreemptionGranularity,
+    NULL, // dxcore_adapter_pGraphicsPreemptionGranularity,
+    NULL, // dxcore_adapter_pDedicatedAdapterMemory,
+    NULL, // dxcore_adapter_pDedicatedSystemMemory,
+    NULL, // dxcore_adapter_pSharedSystemMemory,
+    NULL, // dxcore_adapter_pAcgCompatible,
+    dxcore_adapter_sIsHardware,
+    NULL, // dxcore_adapter_pIsIntegrated,
+    NULL, // dxcore_adapter_pIsDetachable,
+    NULL, // dxcore_adapter_pHardwareIDParts,
+    NULL, // dxcore_adapter_pPhysicalAdapterCount,
+    NULL, // dxcore_adapter_pAdapterEngineCount,
+    NULL // dxcore_adapter_pAdapterEngineName
+};
+
+
+ULONG STDMETHODCALLTYPE dxcore_adapter_AddRef(IDXCoreAdapter *iface) {
+    LONG count;
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    count = InterlockedIncrement(&this->refcount);
+    return count;
+}
+
+
+ULONG STDMETHODCALLTYPE dxcore_adapter_Release(IDXCoreAdapter *iface) {
+    LONG count;
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    count = InterlockedDecrement(&this->refcount);
+    if (!count) {
+        IUnknown_Release(&this->factory->IDXCoreAdapterFactory_iface);
+        free(this);
+    }
+    return count;
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryInterface(IDXCoreAdapter *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    *ppv = NULL;
+    TRACE("riid %s, factory %p.\n", wine_dbgstr_guid(riid), ppv);
+
+
+    if (IsEqualIID(riid, &IID_IUnknown)
+        ||IsEqualIID(riid, &IID_IDXCoreAdapter))
+    {
+        *ppv = iface;
+        iface->lpVtbl->AddRef(iface);
+        return S_OK;
+    }
+
+    /*
+    -- AFFINITY SPECIFIC --
+    d3d12_main.c/wined3d_get_adapter somehow gets passed this adapter object. To avoid having to rewrite d3d12
+    (which still allow users to inject other d3d implementations), we just return our inner IDXGIAdapter here.
+    */
+    return IUnknown_QueryInterface(this->adapter, riid, ppv);
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetFactory(IDXCoreAdapter *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+    IDXCoreAdapterFactory *factory = &this->factory->IDXCoreAdapterFactory_iface;
+    return IUnknown_QueryInterface(factory, riid, ppv);
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsPropertySupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterProperty property
+) {
+    TRACE("property %d\n", property);
+    return !((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL));
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetProperty(
+    IDXCoreAdapter *iface,
+    DXCoreAdapterProperty property, size_t buffer, void *propertyData
+) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    TRACE("property %d, buffer %lld, propertyData %p\n",
+        property, (long long)buffer, propertyData);
+
+    if ((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL))
+        return DXGI_ERROR_UNSUPPORTED;
+
+    return dxcore_adapter_properties[property](this, buffer, propertyData);
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetPropertySize(
+    IDXCoreAdapter *iface,
+    DXCoreAdapterProperty property, size_t *bufferSize
+) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+    TRACE("property %d, bufferSize %p\n", property, bufferSize);
+
+    if ((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL))
+        return DXGI_ERROR_UNSUPPORTED;
+
+    *bufferSize = dxcore_adapter_property_sizes[property](this);
+    return S_OK;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsAttributeSupported(
+    IDXCoreAdapter *this,
+    REFGUID attributeGUID
+) {
+    FIXME("attributeGUID %s stub!\n", wine_dbgstr_guid(attributeGUID));
+    return TRUE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsQueryStateSupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state
+) {
+    FIXME("state %d stub!\n", state);
+    return FALSE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsSetStateSupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state
+) {
+    FIXME("state %d, stub!\n", state);
+    return FALSE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsValid(
+    IDXCoreAdapter *this
+) {
+    FIXME("assuming valid; stub!\n");
+    return TRUE;
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryState(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state,
+    size_t inputStateDetailsSize,
+    void const *inputStateDetails,
+    size_t outputBufferSize,
+    void * outputBuffer
+) {
+    FIXME("state %d, inputStateDetailSize %lld, inputStateDetails %p, stub!\n",
+        state, (long long)inputStateDetailsSize, inputStateDetails);
+    return DXGI_ERROR_UNSUPPORTED;
+}
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_SetState(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state,
+    size_t inputStateDetailsSize,
+    void const *inputStateDetails,
+    size_t inputDataSize,
+    void const *inputData
+) {
+    FIXME("state %d, inputStateDetailsSize %lld, inputStateDetails %p, stub!\n",
+        state, (long long)inputStateDetailsSize, inputStateDetails);
+    return DXGI_ERROR_UNSUPPORTED;
+}
+
+
+static IDXCoreAdapterVtbl dxcore_adapter_vtbl = {
+    dxcore_adapter_QueryInterface,
+    dxcore_adapter_AddRef,
+    dxcore_adapter_Release,
+    dxcore_adapter_IsValid,
+    dxcore_adapter_IsAttributeSupported,
+    dxcore_adapter_IsPropertySupported,
+    dxcore_adapter_GetProperty,
+    dxcore_adapter_GetPropertySize,
+    dxcore_adapter_IsQueryStateSupported,
+    dxcore_adapter_QueryState,
+    dxcore_adapter_IsSetStateSupported,
+    dxcore_adapter_SetState,
+    dxcore_adapter_GetFactory
+};
+
+
+HRESULT dxcore_adapter_create(
+    struct dxcore_factory *factory,
+    IDXGIAdapter *adapter,
+    struct dxcore_adapter **result
+) {
+    struct dxcore_adapter *this;
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    this->refcount = 1;
+    this->IDXCoreAdapter_iface.lpVtbl = &dxcore_adapter_vtbl;
+    this->factory = factory;
+    this->adapter = adapter;
+    IUnknown_AddRef(&factory->IDXCoreAdapterFactory_iface);
+    IUnknown_AddRef(adapter);
+
+    *result = this;
+    return S_OK;
+}
diff -uNarp a/dlls/dxcore/factory.c b/dlls/dxcore/factory.c
--- a/dlls/dxcore/factory.c	1969-12-31 19:00:00.000000000 -0500
+++ b/dlls/dxcore/factory.c	2025-11-18 23:34:50.665954262 -0500
@@ -0,0 +1,346 @@
+#include "private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
+
+
+// -- IDXCoreAdapterList --
+static inline struct dxcore_adapter_list *impl_from_IDXCoreAdapterList(IDXCoreAdapterList *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_adapter_list, IDXCoreAdapterList_iface);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_adapter_list_AddRef(IDXCoreAdapterList *_this) {
+    ULONG refcount;
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(_this);
+
+    refcount = InterlockedIncrement(&this->refcount);
+    return refcount;
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_adapter_list_Release(IDXCoreAdapterList *_this) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(_this);
+
+    ULONG refcount = InterlockedDecrement(&this->refcount);
+    if (!refcount) {
+        IUnknown_Release(&this->factory->IDXCoreAdapterFactory_iface);
+        free(this);
+    }
+    return refcount;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_QueryInterface(
+    IDXCoreAdapterList *this,
+    REFIID iid, void **factory
+) {
+    *factory = NULL;
+    TRACE("this %p, riid, %s, factory, %p\n", this, wine_dbgstr_guid(iid), factory);
+    if (IsEqualIID(iid, &IID_IDXCoreAdapterList)
+        ||IsEqualIID(iid, &IID_IUnknown))
+    {
+        *factory = this;
+        this->lpVtbl->AddRef(this);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+
+static uint32_t STDMETHODCALLTYPE dxcore_adapter_list_GetAdapterCount(IDXCoreAdapterList *iface) {
+    UINT count;
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    count = this->len;
+    TRACE("adapter count %d\n", count);
+    return count;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetAdapter(IDXCoreAdapterList *iface, uint32_t index, REFIID riid, void **ppv) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    *ppv = NULL;
+    TRACE("index %d, riid %s, ppv %p\n", index, wine_dbgstr_guid(riid), ppv);
+
+    if (index >= this->len)
+        return E_INVALIDARG;
+
+    return IUnknown_QueryInterface(&this->adapters[index]->IDXCoreAdapter_iface, riid, ppv);
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsStale(IDXCoreAdapterList *this) {
+    FIXME("stub\n");
+    return FALSE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_Sort(
+    IDXCoreAdapterList *this,
+    uint32_t numPreferences, const DXCoreAdapterPreference *preferences
+) {
+    FIXME("numPreferences %d, preferences %p, stub\n", numPreferences, preferences);
+    return E_NOINTERFACE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetFactory(IDXCoreAdapterList *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    return IUnknown_QueryInterface(
+        &this->factory->IDXCoreAdapterFactory_iface,
+        riid, ppv
+    );
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsAdapterPreferenceSupported(
+    IDXCoreAdapterList *this, DXCoreAdapterPreference preference
+) {
+    FIXME("preference %d, stub\n", preference);
+    return FALSE;
+}
+
+
+static const IDXCoreAdapterListVtbl dxcore_adapter_list_vtbl = {
+    dxcore_adapter_list_QueryInterface,
+    dxcore_adapter_list_AddRef,
+    dxcore_adapter_list_Release,
+    dxcore_adapter_list_GetAdapter,
+    dxcore_adapter_list_GetAdapterCount,
+    dxcore_adapter_list_IsStale,
+    dxcore_adapter_list_GetFactory,
+    dxcore_adapter_list_Sort,
+    dxcore_adapter_list_IsAdapterPreferenceSupported
+};
+
+
+static HRESULT dxcore_adapter_list_init(
+    struct dxcore_adapter_list* this,
+    IDXGIFactory *dxgi_factory,
+    const GUID* filter
+) {
+    IDXGIAdapter *adapter;
+    HRESULT hr = 0;
+
+    this->len = 0;
+
+    // note: we're technically ignoring the filterAttributes
+    // feel free to add them if you know how
+
+    // count the adapters
+    while (!hr) {
+        hr = IDXGIFactory_EnumAdapters(
+            dxgi_factory, this->len, &adapter);
+        if (hr)
+            break;
+        IUnknown_Release(adapter);
+        this->len++;
+    }
+    if (!this->len)
+        return S_OK;
+
+    if (!(this->adapters = calloc(this->len, sizeof(struct dxcore_adapter*))))
+        return E_OUTOFMEMORY;
+
+    for (int i=0; i<this->len; i++) {
+        hr = IDXGIFactory_EnumAdapters(
+            dxgi_factory, i, &adapter);
+        if (hr)
+            break;
+        hr = dxcore_adapter_create(this->factory, adapter, &this->adapters[i]);
+        IUnknown_Release(adapter);
+        if (FAILED(hr))
+            break;
+    }
+    return hr;
+}
+
+
+static HRESULT dxcore_adapter_list_create(
+    struct dxcore_factory *factory,
+    uint32_t numAttributes, const GUID* filterAttributes,
+    REFIID riid, void **ppv
+) {
+    HRESULT result;
+    IDXCoreAdapterList *iface;
+    struct dxcore_adapter_list *this;
+    IDXGIFactory *dxgi_factory;
+
+    if (!numAttributes && filterAttributes)
+        return E_INVALIDARG;
+
+    if (FAILED(result = CreateDXGIFactory1(&IID_IDXGIFactory, (void**)&dxgi_factory)))
+        return result;
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    this->refcount = 1;
+    this->dxgi_factory = dxgi_factory;
+    IUnknown_AddRef(&factory->IDXCoreAdapterFactory_iface);
+    this->factory = factory;
+    iface = &this->IDXCoreAdapterList_iface;
+    iface->lpVtbl = &dxcore_adapter_list_vtbl;
+
+    if (FAILED(result = dxcore_adapter_list_init(this, dxgi_factory, filterAttributes))) {
+        IUnknown_Release(iface);
+        return result;
+    }
+
+    result = IUnknown_QueryInterface(iface, riid, ppv);
+    IUnknown_Release(iface);
+    return result;
+}
+
+
+// -- IDXCoreAdapterFactory --
+static struct dxcore_factory *dxcore_factory_singleton = NULL;
+
+
+static inline struct dxcore_factory *impl_from_IDXCoreAdapterFactory(IDXCoreAdapterFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_factory, IDXCoreAdapterFactory_iface);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_factory_AddRef(IDXCoreAdapterFactory *iface) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+    return InterlockedIncrement(&this->refcount);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_factory_Release(IDXCoreAdapterFactory *iface) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+    ULONG refcount = InterlockedDecrement(&this->refcount);
+
+    if (!refcount) {
+        dxcore_factory_singleton = NULL;
+        free(this);
+    }
+    return refcount;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_QueryInterface(
+    IDXCoreAdapterFactory *this,
+    REFIID iid, void **factory
+) {
+    *factory = NULL;
+    TRACE("this %p, riid, %s, factory, %p\n", this, wine_dbgstr_guid(iid), factory);
+    if (IsEqualIID(iid, &IID_IDXCoreAdapterFactory)
+            || IsEqualIID(iid, &IID_IUnknown))
+    {
+        *factory = this;
+        this->lpVtbl->AddRef(this);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_CreateAdapterList(
+    IDXCoreAdapterFactory *iface,
+    uint32_t num_attributes, const GUID *filter_attributes,
+    REFIID riid, void **ppv
+) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+
+    TRACE("num_attributes %d, filter_attributes %p, riid %s, ppv %p\n",
+        num_attributes, filter_attributes, wine_dbgstr_guid(riid), ppv);
+
+    return dxcore_adapter_list_create(this, num_attributes, filter_attributes, riid, ppv);
+}
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_GetAdapterByLuid(
+    IDXCoreAdapterFactory *this,
+    REFLUID adapter_luid,
+    REFIID riid, void **ppv
+) {
+    FIXME("this %p, adapter_luid %p, riid %s, ppv %p, stub!\n",
+        this, adapter_luid, wine_dbgstr_guid(riid), ppv);
+    return E_INVALIDARG;
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_factory_IsNotificationTypeSupported(
+    IDXCoreAdapterFactory *this,
+    DXCoreNotificationType type
+) {
+    FIXME("type %i\n", type);
+    return (type < 2);
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_RegisterEventNotification(
+    IDXCoreAdapterFactory *this,
+    IUnknown *dxcore_object, DXCoreNotificationType type,
+    PFN_DXCORE_NOTIFICATION_CALLBACK callback, void *callback_context,
+    uint32_t *event_cookie
+) {
+    FIXME("dxcore_object %p, type %d, callback %p, callback_context %p, event_cookie %p\n",
+        dxcore_object, type, callback, callback_context, event_cookie);
+    if (type < 2)
+        return S_OK;
+    return DXGI_ERROR_INVALID_CALL;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_UnregisterEventNotification(
+    IDXCoreAdapterFactory *this,
+    uint32_t event_cookie
+) {
+    FIXME("event_cookie %d\n", event_cookie);
+    return S_OK;
+}
+
+
+static const struct IDXCoreAdapterFactoryVtbl dxcore_factory_vtbl = {
+    dxcore_factory_QueryInterface,
+    dxcore_factory_AddRef,
+    dxcore_factory_Release,
+    dxcore_factory_CreateAdapterList,
+    dxcore_factory_GetAdapterByLuid,
+    dxcore_factory_IsNotificationTypeSupported,
+    dxcore_factory_RegisterEventNotification,
+    dxcore_factory_UnregisterEventNotification,
+};
+
+
+static HRESULT dxcore_factory_init(struct dxcore_factory *this) {
+    dxcore_factory_singleton = this;
+    this->IDXCoreAdapterFactory_iface.lpVtbl = &dxcore_factory_vtbl;
+    this->refcount = 1;
+
+    return S_OK;
+}
+
+
+HRESULT dxcore_factory_create(REFIID riid, void **ppv) {
+    struct dxcore_factory *this;
+    HRESULT res;
+
+    *ppv = NULL;
+
+    if (dxcore_factory_singleton != NULL) {
+        TRACE("Reusing factory %p\n", dxcore_factory_singleton);
+        return IUnknown_QueryInterface(
+            &dxcore_factory_singleton->IDXCoreAdapterFactory_iface, riid, ppv
+        );
+    }
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    if (FAILED(res = dxcore_factory_init(this))) {
+        WARN("Failed to initialize factory, hr %#lx.\n", res);
+        free(this);
+        return res;
+    }
+
+    TRACE("Created factory %p.\n", this);
+    *ppv = this;
+    return S_OK;
+}
diff -uNarp a/dlls/dxcore/main.c b/dlls/dxcore/main.c
--- a/dlls/dxcore/main.c	2025-03-21 16:59:52.000000000 -0400
+++ b/dlls/dxcore/main.c	2025-11-18 23:34:57.260674756 -0500
@@ -16,13 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "dxcore.h"
-#include "wine/debug.h"
+#define DXCORE_INIT_GUID
+#include "private.h"
+
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
 
 HRESULT WINAPI DXCoreCreateAdapterFactory( REFIID riid, void **ppv )
 {
-    FIXME( "riid %s, ppv %p stub!\n", debugstr_guid(riid), ppv );
-    return E_NOINTERFACE;
+    TRACE( "riid %s, ppv %p\n", debugstr_guid(riid), ppv );
+    return dxcore_factory_create(riid, ppv);
 }
diff -uNarp a/dlls/dxcore/Makefile.in b/dlls/dxcore/Makefile.in
--- a/dlls/dxcore/Makefile.in	2025-03-21 16:59:52.000000000 -0400
+++ b/dlls/dxcore/Makefile.in	2025-11-18 23:34:50.663814869 -0500
@@ -1,6 +1,10 @@
 MODULE = dxcore.dll
 
 EXTRADLLFLAGS = -Wb,--prefer-native
+IMPORTLIB = dxcore
+IMPORTS = dxgi dxguid uuid wined3d user32 win32u
 
 SOURCES = \
-	main.c
+	main.c \
+	factory.c \
+	adapter.c
diff -uNarp a/dlls/dxcore/private.h b/dlls/dxcore/private.h
--- a/dlls/dxcore/private.h	1969-12-31 19:00:00.000000000 -0500
+++ b/dlls/dxcore/private.h	2025-11-18 23:34:57.260715787 -0500
@@ -0,0 +1,54 @@
+
+#ifndef __WINE_DXCORE_PRIVATE_H
+#define __WINE_DXCORE_PRIVATE_H
+
+#include "wine/debug.h"
+
+// #include <assert.h>
+
+#define COBJMACROS
+#include "winbase.h"
+#include "objbase.h"
+
+#include "dxgi1_6.h"
+#ifdef DXCORE_INIT_GUID
+#include "initguid.h"
+#endif
+
+#include "dxcore.h"
+#include "dxcore_interface.h"
+
+// IDXCoreAdapterFactory
+struct dxcore_factory {
+    IDXCoreAdapterFactory IDXCoreAdapterFactory_iface;
+    LONG refcount;
+};
+
+HRESULT dxcore_factory_create(REFIID iid, void** factory);
+
+// IDXCoreAdapterList
+struct dxcore_adapter_list {
+    IDXCoreAdapterList IDXCoreAdapterList_iface;
+    LONG refcount;
+    struct dxcore_factory *factory;
+    LONG len;
+    IDXGIFactory *dxgi_factory;
+    struct dxcore_adapter **adapters;
+};
+
+
+// IDXCoreAdapter
+struct dxcore_adapter {
+    IDXCoreAdapter IDXCoreAdapter_iface;
+    LONG refcount;
+    struct dxcore_factory *factory;
+    IDXGIAdapter *adapter;
+};
+
+HRESULT dxcore_adapter_create(
+    struct dxcore_factory *factory,
+    IDXGIAdapter *adapter,
+    struct dxcore_adapter **ppv
+);
+
+#endif
-- 
2.47.1

