
ElementalWarrior wine patch series
https://gitlab.winehq.org/ElementalWarrior/wine/-/commits/affinity-photo3-wine9.13-part3

win32u: Introduce a new vulkan offscreen surfaces list (274a0938)
win32u: Move vulkan surfaces to their new parent when reparenting (340ba20c)
win32u: Detach offscreen, child or vulkan surfaces for another process (f1c63ffd)
win32u: Detach vulkan surfaces that aren't fully visible (92a038bd)
win32u: Make sure vulkan windows have a pixel format selected (2c7ad6b2)
winex11: Also attach child client windows to their toplevel window (8b47de92)
win32u: Pass a HDC parameter to vulkan_surface_detach (7b8bafaa)
winex11: Return an offscreen HDC from vulkan_surface_detach (1728e069)
win32u: Use GDI blit to implement partial or other process presentation (0c0dec90)
Add in dpi context for nt calls (7b8d4ed6)


diff -uarp a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
--- a/dlls/shell32/iconcache.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/shell32/iconcache.c	2025-11-17 17:59:47.340066211 -0500
@@ -1008,6 +1008,8 @@ HRESULT WINAPI SHGetStockIconInfo(SHSTOC
         FIXME("flags 0x%x not implemented\n", flags);
 
     sii->hIcon = NULL;
+    if (flags & SHGSI_ICON)
+        sii->hIcon = LoadIconW(GetModuleHandleW(sii->szPath), MAKEINTRESOURCEW(sii->iIcon));
     sii->iSysImageIndex = -1;
 
     TRACE("%3d: returning %s (%d)\n", id, debugstr_w(sii->szPath), sii->iIcon);
diff -uarp a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
--- a/dlls/win32u/ntuser_private.h	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/win32u/ntuser_private.h	2025-11-17 17:56:20.306044767 -0500
@@ -247,6 +247,8 @@ extern void *(*p_vkGetInstanceProcAddr)(
 
 extern BOOL vulkan_init(void);
 extern void vulkan_detach_surfaces( struct list *surfaces );
+extern void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent );
+extern void vulkan_set_region( HWND toplevel, HRGN region );
 
 /* window.c */
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type );
diff -uarp a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
--- a/dlls/win32u/vulkan.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/win32u/vulkan.c	2025-11-17 17:56:20.307267211 -0500
@@ -48,6 +48,9 @@ static struct vulkan_funcs vulkan_funcs;
 #ifdef SONAME_LIBVULKAN
 
 static const struct vulkan_driver_funcs *driver_funcs;
+/* list of surfaces attached to other processes / desktop windows */
+static struct list offscreen_surfaces = LIST_INIT(offscreen_surfaces);
+static pthread_mutex_t vulkan_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static VkResult (*p_vkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
@@ -57,6 +60,8 @@ struct surface
     struct list entry;
     VkSurfaceKHR host_surface;
     void *driver_private;
+    HDC offscreen_dc;
+    HRGN region;
     HWND hwnd;
 };
 
@@ -73,6 +78,7 @@ static inline VkSurfaceKHR surface_to_ha
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin32SurfaceCreateInfoKHR *info,
                                                 const VkAllocationCallbacks *allocator, VkSurfaceKHR *handle )
 {
+    HWND toplevel = NtUserGetAncestor( info->hwnd, GA_ROOT );
     struct surface *surface;
     VkResult res;
     WND *win;
@@ -87,14 +93,24 @@ static VkResult win32u_vkCreateWin32Surf
         return res;
     }
 
-    if (!(win = get_win_ptr( info->hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
-        list_init( &surface->entry );
+    /* make sure the window has a pixel format selected to get consistent window surface updates */
+    if (!win32u_get_window_pixel_format( info->hwnd )) win32u_set_window_pixel_format( info->hwnd, 1, TRUE );
+
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_add_tail( &offscreen_surfaces, &surface->entry );
+        pthread_mutex_unlock( &vulkan_mutex );
+        driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private, &surface->offscreen_dc );
+    }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
         release_win_ptr( win );
+        if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
 
+    surface->region = NtGdiCreateRectRgn( 0, 0, 0, 0 );
     surface->hwnd = info->hwnd;
     *handle = surface_to_handle( surface );
     return VK_SUCCESS;
@@ -107,9 +123,15 @@ static void win32u_vkDestroySurfaceKHR(
     TRACE( "instance %p, handle 0x%s, allocator %p\n", instance, wine_dbgstr_longlong(handle), allocator );
     if (allocator) FIXME( "Support for allocation callbacks not implemented yet\n" );
 
+    pthread_mutex_lock( &vulkan_mutex );
     list_remove( &surface->entry );
+    pthread_mutex_unlock( &vulkan_mutex );
+
+    if (surface->offscreen_dc) NtGdiDeleteObjectApp( surface->offscreen_dc );
     p_vkDestroySurfaceKHR( instance, surface->host_surface, NULL /* allocator */ );
     driver_funcs->p_vulkan_surface_destroy( surface->hwnd, surface->driver_private );
+    NtGdiDeleteObjectApp( surface->region );
+
     free( surface );
 }
 
@@ -127,7 +149,27 @@ static VkResult win32u_vkQueuePresentKHR
         VkResult swapchain_res = present_info->pResults ? present_info->pResults[i] : res;
         struct surface *surface = surface_from_handle( surfaces[i] );
 
-        driver_funcs->p_vulkan_surface_presented( surface->hwnd, swapchain_res );
+        if (surface->hwnd)
+            driver_funcs->p_vulkan_surface_presented( surface->hwnd, swapchain_res );
+
+        if (swapchain_res >= VK_SUCCESS && surface->offscreen_dc)
+        {
+            UINT width, height;
+            RECT client_rect;
+            HDC hdc_dst;
+            NtUserGetClientRect( surface->hwnd, &client_rect, get_dpi_for_window(surface->hwnd) );
+            width = client_rect.right - client_rect.left;
+            height = client_rect.bottom - client_rect.top;
+
+            WARN("Copying vulkan child window %p rect %s\n", surface->hwnd, wine_dbgstr_rect(&client_rect));
+
+            if ((hdc_dst = NtUserGetDCEx(surface->hwnd, surface->region, DCX_USESTYLE | DCX_CACHE)))
+            {
+                NtGdiStretchBlt(hdc_dst, client_rect.left, client_rect.top, width, height,
+                                surface->offscreen_dc, 0, 0, width, height, SRCCOPY, 0);
+                NtUserReleaseDC(surface->hwnd, hdc_dst);
+            }
+        }
     }
 
     return res;
@@ -187,7 +229,11 @@ static void nulldrv_vulkan_surface_destr
 {
 }
 
-static void nulldrv_vulkan_surface_detach( HWND hwnd, void *private )
+static void nulldrv_vulkan_surface_attach( HWND hwnd, void *private )
+{
+}
+
+static void nulldrv_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
 }
 
@@ -209,6 +255,7 @@ static const struct vulkan_driver_funcs
 {
     .p_vulkan_surface_create = nulldrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = nulldrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = nulldrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = nulldrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = nulldrv_vulkan_surface_presented,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = nulldrv_vkGetPhysicalDeviceWin32PresentationSupportKHR,
@@ -253,10 +300,16 @@ static void lazydrv_vulkan_surface_destr
     return driver_funcs->p_vulkan_surface_destroy( hwnd, private );
 }
 
-static void lazydrv_vulkan_surface_detach( HWND hwnd, void *private )
+static void lazydrv_vulkan_surface_attach( HWND hwnd, void *private )
+{
+    vulkan_driver_load();
+    return driver_funcs->p_vulkan_surface_attach( hwnd, private );
+}
+
+static void lazydrv_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
     vulkan_driver_load();
-    return driver_funcs->p_vulkan_surface_detach( hwnd, private );
+    return driver_funcs->p_vulkan_surface_detach( hwnd, private, hdc );
 }
 
 static void lazydrv_vulkan_surface_presented( HWND hwnd, VkResult result )
@@ -281,6 +334,7 @@ static const struct vulkan_driver_funcs
 {
     .p_vulkan_surface_create = lazydrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = lazydrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = lazydrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = lazydrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = lazydrv_vulkan_surface_presented,
 };
@@ -315,14 +369,123 @@ static void vulkan_init_once(void)
 
 void vulkan_detach_surfaces( struct list *surfaces )
 {
+    struct surface *surface;
+
+    LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
+    {
+        if (surface->offscreen_dc) continue;
+        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
+    }
+
+    pthread_mutex_lock( &vulkan_mutex );
+    list_move_tail( &offscreen_surfaces, surfaces );
+    pthread_mutex_unlock( &vulkan_mutex );
+}
+
+static void append_window_surfaces( HWND toplevel, struct list *surfaces )
+{
+    WND *win;
+
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_move_tail( &offscreen_surfaces, surfaces );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
+    else
+    {
+        list_move_tail( &win->vulkan_surfaces, surfaces );
+        release_win_ptr( win );
+    }
+}
+
+static void enum_window_surfaces( HWND toplevel, HWND hwnd, struct list *surfaces )
+{
+    struct list tmp_surfaces = LIST_INIT(tmp_surfaces);
     struct surface *surface, *next;
+    WND *win;
+
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_move_tail( &tmp_surfaces, &offscreen_surfaces );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
+    else
+    {
+        list_move_tail( &tmp_surfaces, &win->vulkan_surfaces );
+        release_win_ptr( win );
+    }
 
-    LIST_FOR_EACH_ENTRY_SAFE( surface, next, surfaces, struct surface, entry )
+    LIST_FOR_EACH_ENTRY_SAFE( surface, next, &tmp_surfaces, struct surface, entry )
     {
-        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+        if (surface->hwnd != hwnd && !NtUserIsChild( hwnd, surface->hwnd )) continue;
         list_remove( &surface->entry );
-        list_init( &surface->entry );
+        list_add_tail( surfaces, &surface->entry );
     }
+
+    append_window_surfaces( toplevel, &tmp_surfaces );
+}
+
+void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
+{
+    struct list surfaces = LIST_INIT(surfaces);
+    HWND new_toplevel, old_toplevel;
+    struct surface *surface;
+
+    TRACE( "hwnd %p new_parent %p old_parent %p\n", hwnd, new_parent, old_parent );
+
+    if (new_parent == NtUserGetDesktopWindow()) new_toplevel = hwnd;
+    else new_toplevel = NtUserGetAncestor( new_parent, GA_ROOT );
+    if (old_parent == NtUserGetDesktopWindow()) old_toplevel = hwnd;
+    else old_toplevel = NtUserGetAncestor( old_parent, GA_ROOT );
+    if (old_toplevel == new_toplevel) return;
+
+    enum_window_surfaces( old_toplevel, hwnd, &surfaces );
+
+    /* surfaces will be re-attached as needed from surface region updates */
+    LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        if (surface->offscreen_dc) continue;
+        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
+    }
+
+    append_window_surfaces( new_toplevel, &surfaces );
+}
+
+void vulkan_set_region( HWND toplevel, HRGN region )
+{
+    struct list surfaces = LIST_INIT(surfaces);
+    struct surface *surface;
+    UINT_PTR dpi = (UINT_PTR)get_dpi_for_window(toplevel);
+
+    enum_window_surfaces( toplevel, toplevel, &surfaces );
+
+    LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        RECT client_rect;
+        BOOL is_clipped;
+
+        NtUserGetClientRect( surface->hwnd, &client_rect, dpi );
+        NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2, dpi);
+        is_clipped = NtGdiRectInRegion( region, &client_rect );
+
+        if (is_clipped && !surface->offscreen_dc)
+        {
+            TRACE( "surface %p is now clipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
+            NtGdiCombineRgn( surface->region, region, 0, RGN_COPY );
+        }
+        else if (!is_clipped && surface->offscreen_dc)
+        {
+            TRACE( "surface %p is now unclipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
+            NtGdiDeleteObjectApp( surface->offscreen_dc );
+            surface->offscreen_dc = NULL;
+        }
+    }
+
+    append_window_surfaces( toplevel, &surfaces );
 }
 
 #else /* SONAME_LIBVULKAN */
diff -uarp a/dlls/win32u/window.c b/dlls/win32u/window.c
--- a/dlls/win32u/window.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/win32u/window.c	2025-11-17 17:56:20.307784853 -0500
@@ -462,6 +462,7 @@ HWND WINAPI NtUserSetParent( HWND hwnd,
     context = set_thread_dpi_awareness_context( get_window_dpi_awareness_context( hwnd ));
 
     user_driver->pSetParent( full_handle, parent, old_parent );
+    vulkan_set_parent( full_handle, parent, old_parent );
 
     winpos.hwnd = hwnd;
     winpos.hwndInsertAfter = HWND_TOP;
@@ -1786,6 +1787,9 @@ static void update_surface_region( HWND
 done:
     if (shape) NtGdiDeleteObjectApp( shape );
     release_win_ptr( win );
+
+    vulkan_set_region( hwnd, region );
+    if (region) NtGdiDeleteObjectApp( region );
 }
 
 
diff -uarp a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
--- a/dlls/winemac.drv/vulkan.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/winemac.drv/vulkan.c	2025-11-17 17:56:20.308159461 -0500
@@ -178,7 +178,11 @@ static void macdrv_vulkan_surface_destro
     wine_vk_surface_destroy(mac_surface);
 }
 
-static void macdrv_vulkan_surface_detach(HWND hwnd, void *private)
+static void macdrv_vulkan_surface_attach(HWND hwnd, void *private)
+{
+}
+
+static void macdrv_vulkan_surface_detach(HWND hwnd, void *private, HDC *hdc)
 {
 }
 
@@ -203,6 +207,7 @@ static const struct vulkan_driver_funcs
 {
     .p_vulkan_surface_create = macdrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = macdrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = macdrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = macdrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = macdrv_vulkan_surface_presented,
 
diff -uarp a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
--- a/dlls/winewayland.drv/vulkan.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/winewayland.drv/vulkan.c	2025-11-17 17:56:20.308325524 -0500
@@ -132,7 +132,11 @@ static void wayland_vulkan_surface_destr
     wine_vk_surface_destroy(client);
 }
 
-static void wayland_vulkan_surface_detach(HWND hwnd, void *private)
+static void wayland_vulkan_surface_attach(HWND hwnd, void *private)
+{
+}
+
+static void wayland_vulkan_surface_detach(HWND hwnd, void *private, HDC *hdc)
 {
 }
 
@@ -175,6 +179,7 @@ static const struct vulkan_driver_funcs
 {
     .p_vulkan_surface_create = wayland_vulkan_surface_create,
     .p_vulkan_surface_destroy = wayland_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = wayland_vulkan_surface_attach,
     .p_vulkan_surface_detach = wayland_vulkan_surface_detach,
     .p_vulkan_surface_presented = wayland_vulkan_surface_presented,
 
diff -uarp a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
--- a/dlls/winex11.drv/vulkan.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/winex11.drv/vulkan.c	2025-11-17 17:56:20.308494908 -0500
@@ -37,6 +37,7 @@
 
 #include "wine/debug.h"
 #include "x11drv.h"
+#include "xcomposite.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -74,13 +75,6 @@ static VkResult X11DRV_vulkan_surface_cr
 
     TRACE( "%p %p %p %p\n", hwnd, instance, surface, private );
 
-    /* TODO: support child window rendering. */
-    if (NtUserGetAncestor( hwnd, GA_PARENT ) != NtUserGetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     if (!(info.window = create_client_window( hwnd, &default_visual, default_colormap )))
     {
         ERR("Failed to allocate client window for hwnd=%p\n", hwnd);
@@ -109,7 +103,7 @@ static void X11DRV_vulkan_surface_destro
     destroy_client_window( hwnd, client_window );
 }
 
-static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private )
+static void X11DRV_vulkan_surface_attach( HWND hwnd, void *private )
 {
     Window client_window = (Window)private;
     struct x11drv_win_data *data;
@@ -118,9 +112,41 @@ static void X11DRV_vulkan_surface_detach
 
     if ((data = get_win_data( hwnd )))
     {
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeUnredirectWindow( gdi_display, client_window, CompositeRedirectManual );
+#endif
+        attach_client_window( data, client_window );
+        release_win_data( data );
+    }
+}
+
+static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
+{
+    static const WCHAR displayW[] = {'D','I','S','P','L','A','Y'};
+    UNICODE_STRING device_str = RTL_CONSTANT_STRING(displayW);
+    Window client_window = (Window)private;
+    struct x11drv_win_data *data;
+
+    TRACE( "%p %p %p\n", hwnd, private, hdc );
+
+    if ((data = get_win_data( hwnd )))
+    {
         detach_client_window( data, client_window );
         release_win_data( data );
     }
+
+    if (hdc && (*hdc = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL )))
+    {
+        struct x11drv_escape_set_drawable escape = {0};
+        escape.code = X11DRV_SET_DRAWABLE;
+        escape.mode = IncludeInferiors;
+        escape.drawable = client_window;
+        NtUserGetClientRect( hwnd, &escape.dc_rect, NtUserGetThreadInfo()->dpi_context );
+        NtGdiExtEscape( *hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeRedirectWindow( gdi_display, client_window, CompositeRedirectManual );
+#endif
+    }
 }
 
 static void X11DRV_vulkan_surface_presented(HWND hwnd, VkResult result)
@@ -145,6 +171,7 @@ static const struct vulkan_driver_funcs
 {
     .p_vulkan_surface_create = X11DRV_vulkan_surface_create,
     .p_vulkan_surface_destroy = X11DRV_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = X11DRV_vulkan_surface_attach,
     .p_vulkan_surface_detach = X11DRV_vulkan_surface_detach,
     .p_vulkan_surface_presented = X11DRV_vulkan_surface_presented,
 
diff -uarp a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
--- a/dlls/winex11.drv/window.c	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/winex11.drv/window.c	2025-11-17 17:56:20.308544820 -0500
@@ -1475,8 +1475,21 @@ static void sync_client_position( struct
 
     if (!data->client_window) return;
 
-    changes.x      = data->client_rect.left - data->whole_rect.left;
-    changes.y      = data->client_rect.top - data->whole_rect.top;
+    if (data->whole_window)
+    {
+        changes.x = data->client_rect.left - data->whole_rect.left;
+        changes.y = data->client_rect.top - data->whole_rect.top;
+    }
+    else
+    {
+        HWND toplevel = NtUserGetAncestor( data->hwnd, GA_ROOT );
+        POINT pos = {data->client_rect.left, data->client_rect.top};
+
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1, NtUserGetThreadInfo()->dpi_context );
+        changes.x = pos.x;
+        changes.y = pos.y;
+    }
+
     changes.width  = min( max( 1, data->client_rect.right - data->client_rect.left ), 65535 );
     changes.height = min( max( 1, data->client_rect.bottom - data->client_rect.top ), 65535 );
 
@@ -1628,11 +1641,8 @@ void detach_client_window( struct x11drv
 
     TRACE( "%p/%lx detaching client window %lx\n", data->hwnd, data->whole_window, client_window );
 
-    if (data->whole_window)
-    {
-        client_window_events_disable( data, client_window );
-        XReparentWindow( gdi_display, client_window, get_dummy_parent(), 0, 0 );
-    }
+    client_window_events_disable( data, client_window );
+    XReparentWindow( gdi_display, client_window, get_dummy_parent(), 0, 0 );
 
     data->client_window = 0;
 }
@@ -1641,20 +1651,35 @@ void detach_client_window( struct x11drv
 /**********************************************************************
  *             attach_client_window
  */
-static void attach_client_window( struct x11drv_win_data *data, Window client_window )
+void attach_client_window( struct x11drv_win_data *data, Window client_window )
 {
+    Window whole_window;
+    POINT pos = {0};
+
     if (data->client_window == client_window || !client_window) return;
 
     TRACE( "%p/%lx attaching client window %lx\n", data->hwnd, data->whole_window, client_window );
 
     detach_client_window( data, data->client_window );
 
-    if (data->whole_window)
+    if ((whole_window = data->whole_window))
     {
-        client_window_events_enable( data, client_window );
-        XReparentWindow( gdi_display, client_window, data->whole_window, data->client_rect.left - data->whole_rect.left,
-                         data->client_rect.top - data->whole_rect.top );
+        pos.x = data->client_rect.left - data->whole_rect.left;
+        pos.y = data->client_rect.top - data->whole_rect.top;
     }
+    else
+    {
+        HWND toplevel = NtUserGetAncestor( data->hwnd, GA_ROOT );
+        whole_window = X11DRV_get_whole_window( toplevel );
+
+        pos.x = data->client_rect.left;
+        pos.y = data->client_rect.top;
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1, NtUserGetThreadInfo()->dpi_context );
+    }
+    if (!whole_window) whole_window = get_dummy_parent();
+
+    client_window_events_enable( data, client_window );
+    XReparentWindow( gdi_display, client_window, whole_window, pos.x, pos.y );
 
     data->client_window = client_window;
 }
@@ -1819,6 +1844,9 @@ static void destroy_whole_window( struct
 {
     TRACE( "win %p xwin %lx/%lx\n", data->hwnd, data->whole_window, data->client_window );
 
+    if (!already_destroyed) detach_client_window( data, data->client_window );
+    else if (data->client_window) client_window_events_disable( data, data->client_window );
+
     if (!data->whole_window)
     {
         if (data->embedded)
@@ -1835,8 +1863,6 @@ static void destroy_whole_window( struct
     }
     else
     {
-        if (!already_destroyed) detach_client_window( data, data->client_window );
-        else if (data->client_window) client_window_events_disable( data, data->client_window );
         XDeleteContext( data->display, data->whole_window, winContext );
         if (!already_destroyed)
         {
@@ -1845,7 +1871,7 @@ static void destroy_whole_window( struct
         }
     }
     if (data->whole_colormap) XFreeColormap( data->display, data->whole_colormap );
-    data->whole_window = data->client_window = 0;
+    data->whole_window = 0;
     data->whole_colormap = 0;
     data->wm_state = WithdrawnState;
     data->net_wm_state = 0;
diff -uarp a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
--- a/dlls/winex11.drv/x11drv.h	2024-07-28 16:02:13.000000000 -0400
+++ b/dlls/winex11.drv/x11drv.h	2025-11-17 17:56:20.309200253 -0500
@@ -646,6 +646,7 @@ extern void read_net_wm_states( Display
 extern void update_net_wm_states( struct x11drv_win_data *data );
 extern void make_window_embedded( struct x11drv_win_data *data );
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual, Colormap colormap );
+extern void attach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void detach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void destroy_client_window( HWND hwnd, Window client_window );
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha );
diff -uarp a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
--- a/include/wine/vulkan_driver.h	2024-07-28 16:02:13.000000000 -0400
+++ b/include/wine/vulkan_driver.h	2025-11-17 17:56:20.309430108 -0500
@@ -21,7 +21,7 @@
 #define __WINE_VULKAN_DRIVER_H
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 34
+#define WINE_VULKAN_DRIVER_VERSION 35
 
 struct vulkan_funcs
 {
@@ -46,7 +46,8 @@ struct vulkan_driver_funcs
 {
     VkResult (*p_vulkan_surface_create)(HWND, VkInstance, VkSurfaceKHR *, void **);
     void (*p_vulkan_surface_destroy)(HWND, void *);
-    void (*p_vulkan_surface_detach)(HWND, void *);
+    void (*p_vulkan_surface_attach)(HWND, void *);
+    void (*p_vulkan_surface_detach)(HWND, void *, HDC *);
     void (*p_vulkan_surface_presented)(HWND, VkResult);
 
     VkBool32 (*p_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice, uint32_t);
-- 
2.47.1

