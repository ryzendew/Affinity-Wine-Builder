
A regression introduced in wine 10.3 causes the Affinity Sub-Tools panel
to appear above other X11 desktop application windows, including the
Open File Explorer window.

Revert winex11: Pass fullscreen flag to is_window_managed
https://gitlab.winehq.org/wine/wine/-/merge_requests/7370/commits


diff -uarp a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
--- a/dlls/winewayland.drv/window.c	2025-03-21 16:59:52.000000000 -0400
+++ b/dlls/winewayland.drv/window.c	2025-11-25 17:22:57.738844104 -0500
@@ -362,7 +362,7 @@ static inline HWND get_active_window(voi
  *
  * Check if a given window should be managed
  */
-static BOOL is_window_managed(HWND hwnd, UINT swp_flags, BOOL fullscreen)
+static BOOL is_window_managed(HWND hwnd, UINT swp_flags, const RECT *window_rect)
 {
     DWORD style, ex_style;
 
@@ -378,10 +378,18 @@ static BOOL is_window_managed(HWND hwnd,
     if (style & WS_THICKFRAME) return TRUE;
     if (style & WS_POPUP)
     {
+        HMONITOR hmon;
+        MONITORINFO mi;
+
         /* popup with sysmenu == caption are managed */
         if (style & WS_SYSMENU) return TRUE;
         /* full-screen popup windows are managed */
-        if (fullscreen) return TRUE;
+        hmon = NtUserMonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);
+        mi.cbSize = sizeof(mi);
+        NtUserGetMonitorInfo(hmon, &mi);
+        if (window_rect->left <= mi.rcWork.left && window_rect->right >= mi.rcWork.right &&
+            window_rect->top <= mi.rcWork.top && window_rect->bottom >= mi.rcWork.bottom)
+            return TRUE;
     }
     /* application windows are managed */
     ex_style = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
@@ -440,7 +448,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd,
     /* Get the managed state with win_data unlocked, as is_window_managed
      * may need to query win_data information about other HWNDs and thus
      * acquire the lock itself internally. */
-    if (!(managed = is_window_managed(hwnd, swp_flags, fullscreen)) && surface) toplevel = owner_hint;
+    if (!(managed = is_window_managed(hwnd, swp_flags, &new_rects->window)) && surface) toplevel = owner_hint;
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     toplevel_data = toplevel && toplevel != hwnd ? wayland_win_data_get_nolock(toplevel) : NULL;
diff -uarp a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
--- a/dlls/winex11.drv/window.c	2025-11-25 15:40:07.755106491 -0500
+++ b/dlls/winex11.drv/window.c	2025-11-25 17:22:57.739414771 -0500
@@ -376,7 +376,7 @@ static struct x11drv_win_data *alloc_win
  *
  * Check if a given window should be managed
  */
-static BOOL is_window_managed( HWND hwnd, UINT swp_flags, BOOL fullscreen )
+static BOOL is_window_managed( HWND hwnd, UINT swp_flags, const RECT *window_rect )
 {
     DWORD style, ex_style;
 
@@ -394,10 +394,18 @@ static BOOL is_window_managed( HWND hwnd
     if (style & WS_THICKFRAME) return TRUE;
     if (style & WS_POPUP)
     {
+        HMONITOR hmon;
+        MONITORINFO mi;
+
         /* popup with sysmenu == caption are managed */
         if (style & WS_SYSMENU) return TRUE;
         /* full-screen popup windows are managed */
-        if (fullscreen) return TRUE;
+        hmon = NtUserMonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY );
+        mi.cbSize = sizeof( mi );
+        NtUserGetMonitorInfo( hmon, &mi );
+        if (window_rect->left <= mi.rcWork.left && window_rect->right >= mi.rcWork.right &&
+            window_rect->top <= mi.rcWork.top && window_rect->bottom >= mi.rcWork.bottom)
+            return TRUE;
     }
     /* application windows are managed */
     ex_style = NtUserGetWindowLongW( hwnd, GWL_EXSTYLE );
@@ -459,6 +467,7 @@ static unsigned long get_mwm_decorations
  */
 static int get_window_attributes( struct x11drv_win_data *data, XSetWindowAttributes *attr )
 {
+    attr->override_redirect = !data->managed;
     attr->colormap          = data->whole_colormap ? data->whole_colormap : default_colormap;
     attr->save_under        = ((NtUserGetClassLongW( data->hwnd, GCL_STYLE ) & CS_SAVEBITS) != 0);
     attr->bit_gravity       = NorthWestGravity;
@@ -470,7 +479,7 @@ static int get_window_attributes( struct
                                KeyPressMask | KeyReleaseMask | FocusChangeMask |
                                KeymapStateMask | StructureNotifyMask | PropertyChangeMask);
 
-    return (CWSaveUnder | CWColormap | CWBorderPixel | CWBackPixel |
+    return (CWOverrideRedirect | CWSaveUnder | CWColormap | CWBorderPixel | CWBackPixel |
             CWEventMask | CWBitGravity | CWBackingStore);
 }
 
@@ -1489,30 +1498,6 @@ static void window_set_wm_state( struct
     XFlush( data->display );
 }
 
-static void window_set_managed( struct x11drv_win_data *data, BOOL new_managed )
-{
-    XSetWindowAttributes attr = {.override_redirect = !new_managed};
-    UINT wm_state = data->desired_state.wm_state;
-    BOOL old_managed = data->managed;
-
-    if (!data->whole_window) return; /* no window, nothing to update */
-    if (old_managed == new_managed) return; /* states are the same, nothing to update */
-    if (!new_managed)
-    {
-        ERR( "Changing window to unmanaged is not supported\n" );
-        return;
-    }
-
-    window_set_wm_state( data, WithdrawnState ); /* no WM_STATE is pending, requested immediately */
-
-    data->managed = new_managed;
-    TRACE( "window %p/%lx, requesting override-redirect %u -> %u serial %lu\n", data->hwnd, data->whole_window,
-           !old_managed, !new_managed, NextRequest( data->display ) );
-    XChangeWindowAttributes( data->display, data->whole_window, CWOverrideRedirect, &attr );
-
-    window_set_wm_state( data, wm_state ); /* queue another WM_STATE request with the desired state */
-}
-
 
 /***********************************************************************
  *     map_window
@@ -1782,9 +1767,8 @@ void make_window_embedded( struct x11drv
 {
     /* the window cannot be mapped before being embedded */
     window_set_wm_state( data, WithdrawnState );
-    if (data->managed) WARN( "Window is already managed, should wait for WithdrawnState\n" );
-    else window_set_managed( data, TRUE );
     data->embedded = TRUE;
+    data->managed = TRUE;
     window_set_wm_state( data, NormalState );
 }
 
@@ -2146,6 +2130,12 @@ static void create_whole_window( struct
     HRGN win_rgn;
     POINT pos;
 
+    if (!data->managed && is_window_managed( data->hwnd, SWP_NOACTIVATE, &data->rects.window ))
+    {
+        TRACE( "making win %p/%lx managed\n", data->hwnd, data->whole_window );
+        data->managed = TRUE;
+    }
+
     if ((win_rgn = NtGdiCreateRectRgn( 0, 0, 0, 0 )) &&
         NtUserGetWindowRgnEx( data->hwnd, win_rgn, 0 ) == ERROR)
     {
@@ -2157,9 +2147,7 @@ static void create_whole_window( struct
     if (data->vis.visualid != default_visual.visualid)
         data->whole_colormap = XCreateColormap( data->display, root_window, data->vis.visual, AllocNone );
 
-    data->managed = is_window_managed( data->hwnd, SWP_NOACTIVATE, FALSE );
-    mask = get_window_attributes( data, &attr ) | CWOverrideRedirect;
-    attr.override_redirect = !data->managed;
+    mask = get_window_attributes( data, &attr );
 
     if (!(cx = data->rects.visible.right - data->rects.visible.left)) cx = 1;
     else if (cx > 65535) cx = 65535;
@@ -2229,7 +2217,6 @@ static void destroy_whole_window( struct
     if (data->whole_colormap) XFreeColormap( data->display, data->whole_colormap );
     data->whole_window = 0;
     data->whole_colormap = 0;
-    data->managed = FALSE;
 
     memset( &data->desired_state, 0, sizeof(data->desired_state) );
     memset( &data->pending_state, 0, sizeof(data->pending_state) );
@@ -2381,7 +2368,7 @@ static BOOL create_desktop_win_data( Win
 
     if (!(data = alloc_win_data( display, hwnd ))) return FALSE;
     data->whole_window = win;
-    window_set_managed( data, TRUE );
+    data->managed = TRUE;
     NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)win );
     set_initial_wm_hints( display, win );
     release_win_data( data );
@@ -2876,6 +2863,7 @@ void X11DRV_SetParent( HWND hwnd, HWND p
         {
             /* destroy the old X windows */
             destroy_whole_window( data, FALSE );
+            data->managed = FALSE;
         }
     }
     else  /* new top level window */
@@ -2908,6 +2896,16 @@ BOOL X11DRV_WindowPosChanging( HWND hwnd
     if (!data && !(data = X11DRV_create_win_data( hwnd, rects ))) return FALSE; /* use default surface */
     data->shaped = shaped;
 
+    /* check if we need to switch the window to managed */
+    if (!data->managed && data->whole_window && is_window_managed( hwnd, swp_flags, &rects->window ))
+    {
+        TRACE( "making win %p/%lx managed\n", hwnd, data->whole_window );
+        release_win_data( data );
+        unmap_window( hwnd );
+        if (!(data = get_win_data( hwnd ))) return FALSE; /* use default surface */
+        data->managed = TRUE;
+    }
+
     ret = !!data->whole_window; /* use default surface if we don't have a window */
     release_win_data( data );
 
@@ -2980,7 +2978,6 @@ void X11DRV_WindowPosChanged( HWND hwnd,
     sync_gl_drawable( hwnd, FALSE );
 
     if (!(data = get_win_data( hwnd ))) return;
-    if (is_window_managed( hwnd, swp_flags, fullscreen )) window_set_managed( data, TRUE );
 
     old_style = new_style & ~(WS_VISIBLE | WS_MINIMIZE | WS_MAXIMIZE);
     if (data->desired_state.wm_state != WithdrawnState) old_style |= WS_VISIBLE;
-- 
2.47.1

